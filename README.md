# TUTORIAL 9 ADPRO  (High Level Networking)
#### Prasetyo Adi Wijonarko / 2206830246
#### Advanced Programming A / DEE <hr>

1. **What are the key differences between unary, server streaming, and bi-directional streaming RPC (Remote Procedure Call) methods, and in what scenarios would each be most suitable?** <br>
   - RPC Unary adalah jenis paling dasar dari Remote Procedure Call (RPC), di mana klien mengirimkan satu permintaan ke server dan kemudian menerima satu balasan sebagai respons. Metode ini sangat efektif untuk tugas-tugas yang memerlukan pertukaran informasi sederhana, seperti verifikasi identitas atau pengisian formulir. Dalam Unary RPC, klien mengirimkan permintaan dan menunggu tanggapan dari server, menjadikannya metode yang sederhana dan sinkron. Ini cocok digunakan ketika klien hanya memerlukan respons tunggal dari server tanpa perlu streaming data atau interaksi berkelanjutan, seperti dalam contoh Payment Service.
   - RPC Streaming Server adalah jenis RPC di mana klien dapat mengirim satu permintaan dan menerima serangkaian balasan dalam bentuk stream dari server. Klien terus menerima data hingga stream tersebut selesai. Pendekatan ini sangat berguna ketika server harus mengirimkan jumlah data yang besar, seperti daftar panjang atau file, kepada klien. Dalam RPC Streaming Server, klien mengirim satu permintaan ke server dan menerima respons dalam bentuk stream yang terdiri dari beberapa pesan. Klien membaca pesan dari stream tersebut hingga tidak ada lagi pesan yang dikirimkan oleh server. Hal ini cocok digunakan ketika server perlu mengirimkan sejumlah besar data kepada klien, seperti daftar panjang atau file.
   - RPC Bi-directional Streaming adalah proses di mana klien dan server saling bertukar pesan melalui stream yang dapat dibaca dan ditulis. Stream ini berfungsi secara mandiri, memungkinkan kedua belah pihak untuk mengirim dan menerima pesan tanpa urutan tertentu. Dalam RPC Bi-directional Streaming, klien dan server dapat mengirim serangkaian pesan menggunakan stream yang dapat dibaca dan ditulis (read-write), yang beroperasi secara independen. Hal ini memungkinkan klien dan server untuk membaca dan menulis data dalam urutan yang berbeda. Pendekatan ini sangat cocok untuk aplikasi yang memerlukan komunikasi dua arah yang intensif, seperti dalam aplikasi chatting, di mana pertukaran data besar antara klien dan server diperlukan secara independen.
2. **What are the potential security considerations involved in implementing a gRPC service in Rust, particularly regarding authentication, authorization, and data encryption?** <br>
Dalam penerapan layanan gRPC menggunakan Rust, aspek keamanan seperti autentikasi, otorisasi, dan pengamanan data sangatlah penting. Setiap elemen data yang ditransfer harus melalui proses autentikasi dan otorisasi untuk menjamin keamanannya. Sistem autentikasi perlu mengadopsi metode yang kuat, seperti sertifikat SSL/TLS klien atau token yang terverifikasi dengan baik, sementara mekanisme otorisasi harus efisien dalam menerapkan kebijakan akses. Selain itu, penting untuk mengenkripsi data yang dikirim antara server dan klien untuk memastikan kerahasiaannya. Implementasi layanan gRPC di Rust harus memperhatikan semua langkah keamanan ini, mulai dari tahap autentikasi hingga enkripsi data, guna menjamin keamanan komunikasi dan integritas informasi yang ditransmisikan.
3. **What are the potential challenges or issues that may arise when handling bidirectional streaming in Rust gRPC, especially in scenarios like chat applications?**<br>
Dalam menerapkan streaming dua arah menggunakan gRPC, beberapa aspek penting harus dikelola dengan cermat. Ini termasuk menangani situasi konkurensi, mengelola kesalahan, memastikan urutan pesan, mengatasi back-pressure, mengalokasikan sumber daya dengan efisien, menjaga keamanan, menghadapi skalabilitas, dan mengurangi latensi. Semua aspek ini harus ditangani dengan baik agar komunikasi antara klien dan server berjalan lancar, pesan tidak terputus, dan masalah konkurensi dapat diatasi. Selain itu, pengelolaan sumber daya yang cerdas dan mempertimbangkan aspek keamanan dan kemampuan peningkatan sistem juga sangat penting. Menyempurnakan kinerja jaringan dan mengurangi latensi juga merupakan tantangan, namun hal ini penting untuk meningkatkan pengalaman pengguna.
4. **What are the advantages and disadvantages of using the tokio_stream::wrappers::ReceiverStream for streaming responses in Rust gRPC services?** <br>
    Keunggulan:
    - Integrasi yang mulus dengan runtime asinkron Tokio, cocok untuk aplikasi yang sudah menggunakan Tokio untuk I/O asinkron.
    - Fleksibel dalam menangani berbagai jenis stream.
    - Data dikelola dengan asinkronus

    Kekurangan:
    - Bergantung pada Tokio sebagai dependensi, sehingga tidak sesuai untuk proyek yang menggunakan runtime asinkron lain.
    - ReceiverStream cocok untuk skenario streaming dasar, tetapi mungkin kurang memiliki fitur lanjutan dan opsi kustomisasi yang tersedia di perpustakaan streaming lain.
    - Mungkin ada kurva belajar bagi pengembang yang baru mempelajari pemrograman asinkron di Rust atau Tokio, terutama jika mereka belum familiar dengan API dan konsep Tokio.
5. **In what ways could the Rust gRPC code be structured to facilitate code reuse and modularity, promoting maintainability and extensibility over time?**<br>
   Dalam pengembangan gRPC di Rust, strategi modularitas dan penggunaan ulang kode dapat diterapkan dengan memisahkan fungsi dan layanan gRPC ke dalam modul yang berbeda, seperti layanan services.proto, implementasi server grpc_server.rs, dan klien grpc_client.rs. Hal ini memungkinkan manajemen kode yang lebih baik dan penggunaan kembali yang efisien. Selain itu, menggunakan trait untuk mendefinisikan fungsionalitas yang dapat dibagi antar komponen akan meningkatkan fleksibilitas dan konfigurasi ulang. Teknik lainnya termasuk mengadopsi library eksternal untuk tugas-tugas umum guna meningkatkan konsistensi dan mengurangi duplikasi. Dengan demikian, implementasi gRPC di Rust akan menjadi lebih modular, mudah dipelihara, dan dapat diperluas secara efisien, memastikan bahwa layanan gRPC dapat diperluas dan dipelihara dengan mudah.
   
6. **In the MyPaymentService implementation, what additional steps might be necessary to handle more complex payment processing logic?** <br>
Untuk meningkatkan implementasi MyPaymentService dalam penanganan logika pemrosesan pembayaran yang lebih kompleks, perlu dilakukan perubahan pada metode process_payment dengan mengubahnya menjadi layanan streaming pada sisi server. Hal ini memungkinkan pengiriman respons secara bertahap kepada klien selama proses pemrosesan pembayaran, yang dapat mengakomodasi pengiriman data yang lebih kompleks dengan lebih efisien. Dengan demikian, memperbaiki MyPaymentService dengan pendekatan ini akan memungkinkan pengelolaan proses pembayaran yang lebih rumit dengan lebih baik, serta memfasilitasi transfer informasi yang lebih lengkap dan terperinci antara server dan klien.
7. **What impact does the adoption of gRPC as a communication protocol have on the overall architecture and design of distributed systems, particularly in terms of interoperability with other technologies and platforms?** <br>
Penggunaan gRPC sebagai protokol komunikasi telah mengubah paradigma desain dan pembangunan sistem terdistribusi. gRPC menghilangkan kebutuhan untuk mempertimbangkan akses modul melalui metode HTTP tradisional dengan menyediakan mekanisme otomatis untuk menghubungkan dan memanggil metode yang diperlukan. Dengan adanya file proto yang menentukan kontrak antara klien dan server, klien dapat memanggil metode server secara langsung dan mudah. Ini tidak hanya menyederhanakan interaksi antar berbagai teknologi dan platform, tetapi juga meningkatkan kemampuan sistem yang berbeda untuk bekerja bersama dalam arsitektur yang kompleks. Dengan demikian, adopsi gRPC telah memberikan dampak signifikan pada arsitektur dan desain sistem terdistribusi, dengan menyederhanakan konektivitas, operasi, dan meningkatkan interoperabilitas antara berbagai komponen sistem.
8. **What are the advantages and disadvantages of using HTTP/2, the underlying protocol for gRPC, compared to HTTP/1.1 or HTTP/1.1 with WebSocket for REST APIs?**<br>
    Keunggulan:
    - Multiplexing dalam HTTP/2 mengelola multiple requests dan responses melalui satu koneksi, mengurangi latency dan meningkatkan performa aplikasi.
    - Fitur prioritas request dan server push mempercepat waktu pemuatan halaman dengan mengirimkan sumber daya sebelum diminta oleh klien.
  
    Kekurangan:
    - Implementasi HTTP/2 lebih kompleks dan memerlukan enkripsi SSL/TLS yang menambah biaya overhead.
    - Meskipun WebSocket di HTTP/1.1 memungkinkan komunikasi dua arah yang efektif, penggunaannya bisa lebih sederhana dalam situasi tertentu dibandingkan dengan HTTP/2, dengan migrasi mungkin memerlukan pertimbangan kompatibilitas dan biaya overhead yang lebih tinggi.
9.  **How does the request-response model of REST APIs contrast with the bidirectional streaming capabilities of gRPC in terms of real-time communication and responsiveness?**<br>
    Dua pendekatan yang berbeda digunakan dalam REST APIs dan bidirectional streaming di gRPC untuk mendukung komunikasi real-time. REST APIs menggunakan model request-respons yang memerlukan koneksi baru untuk setiap respons, menyebabkan latensi yang tinggi, sementara gRPC dengan HTTP/2 mendukung bidirectional streaming, mengurangi latensi dan meningkatkan efisiensi. Meskipun REST API mudah digunakan, tidak mendukung komunikasi real-time, sementara gRPC dengan fitur streaming dua arah memberikan responsivitas yang lebih baik.
10. **What are the implications of the schema-based approach of gRPC, using Protocol Buffers, compared to the more flexible, schema-less nature of JSON in REST API payloads?**<br>
    gRPC dengan Protocol Buffer menawarkan keuntungan kompatibilitas dan efisiensi berkat struktur berbasis skema. Ini cocok untuk situasi yang memerlukan tipe data yang ketat dan performa tinggi. Di sisi lain, JSON dalam REST API memberikan keleluasaan dan kemudahan baca lintas bahasa, meskipun bisa memerlukan biaya lebih. Namun, pendekatan berbasis skema dalam gRPC membantu mengoptimisasi data, mengurangi penggunaan bandwidth, dan meningkatkan kecepatan pemrosesan data. JSON, sementara fleksibel, mungkin lebih lambat dan memakan lebih banyak sumber daya karena tidak memerlukan skema, serta dapat meningkatkan risiko kesalahan runtime dan interpretasi data yang tidak konsisten.